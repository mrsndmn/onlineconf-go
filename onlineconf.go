// Package onlineconf reads configuration files generated by OnlineConf.
//
// It opens indexed CDB files and maps them in the memory.
// If onlineconf-updater modifies them, they are automatically reopened.
package onlineconf

import (
	"fmt"
	"log"
	"path"
	"path/filepath"
	"strconv"

	"github.com/alldroll/cdb"
	"github.com/fsnotify/fsnotify"
	"golang.org/x/exp/mmap"
)

// DefaultModulesDir defines default direcotry for modules
const DefaultModulesDir = "/usr/local/etc/onlineconf"

// OCPath is a type of path of any parameter in Onlineconf's CDB.
// It aliased to []byte. You can use it to avoid unnecessary
// copying in string to []bytes converting. Example:
// 	onlineconf.GetInt("/path/to/param"..., 0)

// ModuleOptions contains onlineconf module options
type ModuleOptions struct {
	Dir       string // Dir points to modules directory
	NoInotify bool
}

// todo
// локи для модулей -- это не вариант. Лучше отдавать копию
// онлайнконфа на каждый запрос

// Module is a structure that associated with onlineconf module file.
type Module struct {
	options      ModuleOptions
	Name         string
	cdbFile      *mmap.ReaderAt
	CDB          cdb.Reader
	watcher      *fsnotify.Watcher
	StringParams map[string]string
	IntParams    map[string]int
}

// NewModuleFromFile opens module from the specified file
func NewModuleFromFile(filePath string) (*Module, error) {
	dir := filepath.Dir(filePath)
	file := filepath.Base(filePath)
	return NewModuleWithOptions(file, ModuleOptions{
		Dir: dir,
	})
}

// NewModule opens onlineconf module from
// onlineconf.DefaultModulesDir
func NewModule(moduleName string) (*Module, error) {
	return NewModuleWithOptions(moduleName, ModuleOptions{
		Dir:       DefaultModulesDir,
		NoInotify: false,
	})
}

// NewModuleWithOptions opens onlineconf module cdb file, maps it on memory,
// parses and setsup inotify watcher for this file.
func NewModuleWithOptions(moduleName string, ops ModuleOptions) (*Module, error) {
	// cdbName := fmt.Sprintf("%s.cdb", moduleName)
	filePath := path.Join(ops.Dir, moduleName)

	cdbFile, err := mmap.Open(filePath)
	if err != nil {
		return nil, fmt.Errorf("Cant open filr %s: %w", filePath, err) // todo check %w works
	}

	cdbReader, err := cdb.New().GetReader(cdbFile)
	if err != nil {
		return nil, fmt.Errorf("Cant cant cdb reader for module %s: %w", moduleName, err)
	}

	var watcher *fsnotify.Watcher

	if !ops.NoInotify {
		watcher, err = fsnotify.NewWatcher()
		if err != nil {
			return nil, fmt.Errorf("Cant init inotify watcher: %w", err)
		}

		err = watcher.Add(filePath)
		if err != nil {
			return nil, fmt.Errorf("Cant add inotify watcher for module %s: %w", moduleName, err)
		}
		go func() {
			for {
				select {
				case ev := <-watcher.Events:

					if ev.Op&fsnotify.Create == fsnotify.Create {
						log.Printf("Inotify event: %#v", ev)
						panic("todo support module reload") //todo support module reload
					}

				case err := <-watcher.Errors:
					if err != nil {
						log.Printf("Watch %v error: %v\n", ops.Dir, err)
					}
				}
			}
		}()
	}

	module := &Module{
		options: ops,
		Name:    moduleName,
		cdbFile: cdbFile,
		CDB:     cdbReader,
		watcher: watcher,
	}

	// todo подумать, как будут обновляться модули
	// кажется, что горутинка при обновлении файлика должна
	// генерить новый модуль и отдавать ссылку нна него по запросу
	// пока файлик не обновится еще раз
	module.fillParams()
	return module, nil
}

// Close stops inotify watcher for module and closes module cdb file
func (m *Module) Close() error {
	if m.watcher != nil {
		err := m.watcher.Close()
		if err != nil {
			return fmt.Errorf("Can't close inotify watcher for module %s, %w", m.Name, err)
		}
	}

	return m.cdbFile.Close()
}

// для того, чтобы не приходилось каждый раз парсить
// содержимое конфига, это можно сделать один раз.
// для этого надо знать, от онлайнконфа, какого типа даннный парамерт
// так же, как это сделано сейас, например, для JSON можно писать подсказки
// в cdb файле и парсить или не парсить данное число.
// Как вариант, можно все параметры, для которых не указан тип,
// пытаться распарсить и как число, и как строку, и как число разных типов uint64 и т д
// то, что получилось, складывать в отдельные мапки и при обращении вообще не ходить в cdb файл
// до этого, наверное, интересно побенчить, на сколько мапка будет быстрее cdb
func (m *Module) fillParams() {
	stringParams := map[string]string{}
	intParams := map[string]int{}

	cdbIter, err := m.CDB.Iterator()
	if err != nil {
		panic(err) // todo fixme
	}

	record := cdbIter.Record()
	_, ks := record.Key()
	log.Printf("1 rec: %d", ks)

	for {
		record := cdbIter.Record()
		if record == nil {
			break
		}

		keyReader, keySize := record.Key()
		key := make([]byte, int(keySize))
		if _, err = keyReader.Read(key); err != nil {
			panic(err)
		}

		valReader, valSize := record.Value()
		val := make([]byte, int(valSize))
		if _, err = valReader.Read(val); err != nil {
			panic(err)
		}

		if len(val) < 1 {
			panic(fmt.Errorf("Onlineconf value must contain at least 1 byte: `typeByte|ParamData`"))
		}

		log.Printf("oc parsing: %s %s", string(key), string(val))

		// val's first byte defines datatype of config value
		// onlineconf currently knows 's' and 'j' data types
		paramTypeByte := val[0]
		if paramTypeByte == 's' { // params type string
			keyStr := string(key)
			valStr := string(val[1:])

			// todo? check val first byte.
			// if its 0
			stringParams[keyStr] = valStr
			log.Printf("str param: %s %s", keyStr, valStr)

			if intParam, err := strconv.Atoi(valStr); err == nil {
				intParams[keyStr] = intParam
				log.Printf("int param: %s %d", keyStr, intParam)
			}
		} else if paramTypeByte == 'j' {
			// not supported yet
			// todo support json params
		} else {
			panic(fmt.Sprintf("Unknown paramTypeByte: %#v for key %s", paramTypeByte, string(key)))
		}

		if !cdbIter.HasNext() {
			break
		}

		_, err := cdbIter.Next()
		if err != nil {
			panic(err) // todo fix me
		}
	}

	m.IntParams = intParams
	m.StringParams = stringParams
	return
}

// String returns value of a named parameter from the module.
// It returns the boolean true if the parameter exists and is a string.
// In the other case it returns the boolean false and an empty string.
func (m *Module) String(path string) (string, bool) {
	param, ok := m.StringParams[path]
	return param, ok
}

// StringWithDef returns value of a named parameter from the module.
// It returns the boolean true if the parameter exists and is a string.
// In the other case it returns the boolean false and an empty string.
func (m *Module) StringWithDef(path string, defaultValue string) (string, bool) {
	param, ok := m.StringParams[path]
	if !ok {
		return defaultValue, ok
	}
	return param, ok
}

// Int returns value of a named parameter from the module.
// It returns the boolean true if the parameter exists and is an int.
// In the other case it returns the boolean false and zero.
func (m *Module) Int(path string) (int, bool) {
	param, ok := m.IntParams[path]
	return param, ok
}

// IntWithDef returns value of a named parameter from the module.
// It returns the boolean true if the parameter exists and is an int.
// In the other case it returns the boolean false and zero.
func (m *Module) IntWithDef(path string, defaultValue int) (int, bool) {
	param, ok := m.IntParams[path]
	if !ok {
		return defaultValue, ok
	}
	return param, ok
}

// MustString returns value of a named parameter from the module.
// It panics if no such parameter or this parameter is not a string.
func (m *Module) MustString(path string) string {
	param, ok := m.StringParams[path]
	if !ok {
		panic(fmt.Errorf("Missing required parameter in onlinecinf module %s: %s", m.Name, path))
	}
	return param
}

// MustInt returns value of a named parameter from the module.
// It panics if no such parameter or this parameter is not an int
func (m *Module) MustInt(path string) int {
	param, ok := m.IntParams[path]
	if !ok {
		panic(fmt.Errorf("Missing required parameter in onlinecinf module %s: %s", m.Name, path))
	}
	return param
}
